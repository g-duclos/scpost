---
title: "scpost: Post-Processing Guide for Single-cell Data"
author: "scpost package"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    highlight: tango
    code_folding: show
vignette: >
  %\VignetteIndexEntry{scpost Post-Processing Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  eval = FALSE  # Set to FALSE since this requires pre-processed data
)

# Memory management
options(future.globals.maxSize = 2 * 1024^3)  # 2GB limit
```


# Introduction

The `scpost` package provides post-processing workflows for single-cell RNA-seq data. The package supports processing of data from three popular single-cell data object types:

- **ExpressionSet** (Biobase) - Classic Bioconductor format
- **Seurat** - Most popular single-cell analysis format
- **SingleCellExperiment** - Modern Bioconductor standard for single-cell data

This vignette demonstrates how to use `scpost` core functions to perform clustering, dimensionality reduction, and batch correction on data that has been prepared by the **[scprep](https://github.com/g-duclos/scprep)** package.


***

# Prerequisites

***

Before using `scpost`, you should have already processed your data with `scprep` (or have a similarly structured object). Your data should include:

- **Cell filtering results** in metadata (column: `Cell_Filter` with values: "Cell", "Dead", or "Debris")
- **Gene filtering results** (for ExpressionSet: `fData()$Gene_Filter` with "Expressed" genes)
- **Quality metrics** (UMIs, Genes, etc.)

```{r prerequisites}
# Load required packages
library(scpost)
library(Biobase)
library(Seurat)
library(SingleCellExperiment)

# Example: Load data that was processed by scprep
# eset <- readRDS("ExpressionSet.rds")        # For ExpressionSet
# seurat_obj <- readRDS("seurat.rds")         # For Seurat
# sce_obj <- readRDS("sce.rds")               # For SingleCellExperiment
```


***

# Core Functions

***

The `scpost` package provides three main functions:

1. **`scpost_seurat_init()`** - Initialize Seurat workflow (normalize, scale, PCA)
2. **`scpost_batch_correction()`** - Perform batch correction (Harmony or CCA)
3. **`scpost_seurat_cluster()`** - Perform graph-based clustering

These can be used individually or combined in the `template_scpost()` workflow.


***

# ExpressionSet Workflow

***

## Input: ExpressionSet from scprep

Assume you have an ExpressionSet object from scprep with cell filtering and gene annotation already completed.

```{r eset_input}
# Load ExpressionSet (example path)
eset <- readRDS("ExpressionSet.rds")

# Check that required metadata exists
print("Cell metadata columns:")
print(colnames(Biobase::pData(eset)))

print("Cell filter distribution:")
print(table(eset$Cell_Filter))
```

## Step 1: Select Cells and Genes

```{r eset_select}
# Select high quality cells
cells <- eset$ID[which(eset$Cell_Filter == "Cell")]
cat("Selected", length(cells), "high quality cells\n")

# Select expressed genes
genes <- Biobase::fData(eset)$Ensembl[which(Biobase::fData(eset)$Gene_Filter == "Expressed")]
cat("Selected", length(genes), "expressed genes\n")
```

## Step 2: Initialize Seurat Workflow

```{r eset_init}
# Run normalization, scaling, and PCA
seurat.obj <- scpost::scpost_seurat_init(
  counts = Biobase::exprs(eset)[genes, cells],
  pc_max = 30,
  verbose = TRUE
)

cat("Seurat object created with", ncol(seurat.obj), "cells\n")
```

## Step 3: Clustering

```{r eset_cluster}
# Perform clustering at resolution 0.5
seurat.obj <- scpost::scpost_seurat_cluster(
  seurat.obj = seurat.obj,
  pc_max = 30,
  resolution = 0.5,
  reduction = "pca",
  seurat_return = TRUE,
  verbose = TRUE
)

# Get cluster assignments
clusters <- as.numeric(Seurat::Idents(seurat.obj))
names(clusters) <- colnames(seurat.obj)
cat("Found", length(unique(clusters)), "clusters\n")

# Store in ExpressionSet
not.clusters <- rep(NA, length(setdiff(eset$ID, names(clusters))))
names(not.clusters) <- setdiff(eset$ID, names(clusters))
seurat.clusters.all <- c(clusters, not.clusters)[eset$ID]
eset$Seurat_Clusters_Res_0.5 <- as.factor(seurat.clusters.all)
```

## Step 4: Dimensionality Reduction

```{r eset_umap}
# Run UMAP
seurat.obj <- Seurat::RunUMAP(
  object = seurat.obj,
  reduction = "pca",
  dims = 1:30,
  verbose = TRUE
)

# Store UMAP in ExpressionSet
Biobase::assayData(eset)$Seurat[["UMAP"]][["Iteration_1"]] <-
  seurat.obj@reductions$umap@cell.embeddings

# Run tSNE
seurat.obj <- Seurat::RunTSNE(
  object = seurat.obj,
  reduction = "pca",
  dims = 1:30,
  verbose = TRUE
)

# Store tSNE in ExpressionSet
Biobase::assayData(eset)$Seurat[["tSNE"]][["Iteration_1"]] <-
  seurat.obj@reductions$tsne@cell.embeddings
```

## Accessing Results

```{r eset_results}
# Access clustering results
clusters <- eset$Seurat_Clusters_Res_0.5
print(table(clusters, useNA = "ifany"))

# Access UMAP coordinates
umap_coords <- Biobase::assayData(eset)$Seurat$UMAP$Iteration_1
print(head(umap_coords))

# Access tSNE coordinates
tsne_coords <- Biobase::assayData(eset)$Seurat$tSNE$Iteration_1
print(head(tsne_coords))
```


***

# Seurat Workflow

***

## Input: Seurat Object from scprep

When your input is already a Seurat object, the workflow is more direct.

```{r seurat_input}
# Load Seurat object (example path)
seurat_obj <- readRDS("seurat.rds")

# Check metadata
print("Cell metadata columns:")
print(colnames(seurat_obj@meta.data))

print("Cell filter distribution:")
print(table(seurat_obj@meta.data$Cell_Filter))
```

## Step 1: Select and Subset

```{r seurat_select}
# Select high quality cells
cells <- rownames(seurat_obj@meta.data)[which(seurat_obj@meta.data$Cell_Filter == "Cell")]

# Subset Seurat object
seurat_obj <- subset(seurat_obj, cells = cells)
cat("Subset to", ncol(seurat_obj), "high quality cells\n")
```

## Step 2: Process with Seurat Functions

```{r seurat_process}
# Normalize
seurat_obj <- Seurat::NormalizeData(seurat_obj, verbose = TRUE)

# Find variable features
seurat_obj <- Seurat::FindVariableFeatures(seurat_obj, verbose = TRUE)

# Scale
seurat_obj <- Seurat::ScaleData(seurat_obj, verbose = TRUE)

# PCA
seurat_obj <- Seurat::RunPCA(seurat_obj, npcs = 30, verbose = TRUE)
```

## Step 3: Clustering

```{r seurat_cluster}
# Use scpost clustering function
seurat_obj <- scpost::scpost_seurat_cluster(
  seurat.obj = seurat_obj,
  pc_max = 30,
  resolution = 0.5,
  reduction = "pca",
  seurat_return = TRUE,
  verbose = TRUE
)

cat("Found", length(unique(Seurat::Idents(seurat_obj))), "clusters\n")
```

## Step 4: Dimensionality Reduction

```{r seurat_dimred}
# UMAP
seurat_obj <- Seurat::RunUMAP(seurat_obj, dims = 1:30, verbose = TRUE)

# tSNE
seurat_obj <- Seurat::RunTSNE(seurat_obj, dims = 1:30, verbose = TRUE)
```

## Accessing Results

```{r seurat_results}
# Clustering
clusters <- Seurat::Idents(seurat_obj)
print(table(clusters))

# UMAP
umap_coords <- seurat_obj@reductions$umap@cell.embeddings
print(head(umap_coords))

# PCA
pca_coords <- seurat_obj@reductions$pca@cell.embeddings
print(head(pca_coords[, 1:5]))
```


***

# SingleCellExperiment Workflow

***

## Input: SCE Object from scprep

```{r sce_input}
# Load SingleCellExperiment object (example path)
sce_obj <- readRDS("sce.rds")

# Check metadata
print("Cell metadata columns:")
print(colnames(SummarizedExperiment::colData(sce_obj)))

print("Cell filter distribution:")
print(table(SummarizedExperiment::colData(sce_obj)$Cell_Filter))
```

## Step 1: Select Cells and Extract Counts

```{r sce_select}
# Select high quality cells
cells <- rownames(SummarizedExperiment::colData(sce_obj))[
  which(SummarizedExperiment::colData(sce_obj)$Cell_Filter == "Cell")
]

# Extract counts
genes <- rownames(sce_obj)
counts_matrix <- SummarizedExperiment::assay(sce_obj, "counts")[genes, cells]
```

## Step 2: Initialize Seurat Workflow

```{r sce_init}
# Process with scpost
seurat.obj <- scpost::scpost_seurat_init(
  counts = counts_matrix,
  pc_max = 30,
  verbose = TRUE
)
```

## Step 3: Clustering

```{r sce_cluster}
# Clustering
seurat.obj <- scpost::scpost_seurat_cluster(
  seurat.obj = seurat.obj,
  pc_max = 30,
  resolution = 0.5,
  reduction = "pca",
  seurat_return = TRUE,
  verbose = TRUE
)

# Store in SCE
clusters <- as.numeric(Seurat::Idents(seurat.obj))
names(clusters) <- colnames(seurat.obj)

all_cell_ids <- rownames(SummarizedExperiment::colData(sce_obj))
not.clusters <- rep(NA, length(setdiff(all_cell_ids, names(clusters))))
names(not.clusters) <- setdiff(all_cell_ids, names(clusters))
seurat.clusters.all <- c(clusters, not.clusters)[all_cell_ids]

SummarizedExperiment::colData(sce_obj)$Seurat_Clusters_Res_0.5 <- as.factor(seurat.clusters.all)
```

## Step 4: Dimensionality Reduction

```{r sce_dimred}
# UMAP
seurat.obj <- Seurat::RunUMAP(seurat.obj, dims = 1:30, verbose = TRUE)

# Store in reducedDims
SingleCellExperiment::reducedDim(sce_obj, "UMAP_Iteration_1") <-
  seurat.obj@reductions$umap@cell.embeddings

# Store PCA
SingleCellExperiment::reducedDim(sce_obj, "PCA") <-
  seurat.obj@reductions$pca@cell.embeddings
```

## Accessing Results

```{r sce_results}
# Clustering
clusters <- SummarizedExperiment::colData(sce_obj)$Seurat_Clusters_Res_0.5
print(table(clusters, useNA = "ifany"))

# UMAP
umap_coords <- SingleCellExperiment::reducedDim(sce_obj, "UMAP_Iteration_1")
print(head(umap_coords))

# PCA
pca_coords <- SingleCellExperiment::reducedDim(sce_obj, "PCA")
print(head(pca_coords[, 1:5]))
```


***

# Batch Correction

***

For datasets with batch effects, use `scpost_batch_correction()` before clustering.

## Example: Harmony Batch Correction

```{r batch_harmony}
# Extract batch variable from metadata (ExpressionSet example)
batch_metadata <- Biobase::pData(eset)[colnames(seurat.obj), "Batch"]
names(batch_metadata) <- colnames(seurat.obj)

# Run Harmony
seurat.obj <- scpost::scpost_batch_correction(
  seurat.obj = seurat.obj,
  batch_metadata = batch_metadata,
  method = "harmony",
  pc_max = 30,
  verbose = TRUE
)

# Now cluster using harmony reduction
seurat.obj <- scpost::scpost_seurat_cluster(
  seurat.obj = seurat.obj,
  pc_max = 30,
  resolution = 0.5,
  reduction = "harmony",  # Use harmony instead of pca
  seurat_return = TRUE,
  verbose = TRUE
)
```

## Example: CCA Batch Correction

```{r batch_cca}
# Run CCA/RPCA integration
seurat.obj <- scpost::scpost_batch_correction(
  seurat.obj = seurat.obj,
  batch_metadata = batch_metadata,
  method = "cca",
  pc_max = 30,
  verbose = TRUE
)

# Cluster using integrated reduction
seurat.obj <- scpost::scpost_seurat_cluster(
  seurat.obj = seurat.obj,
  pc_max = 30,
  resolution = 0.5,
  reduction = "pca",  # CCA creates integrated assay
  seurat_return = TRUE,
  verbose = TRUE
)
```


***

# Template Workflow (Recommended)

***

For automated processing, use `template_scpost()` with a parameter file.

## Create Parameter File

Create `scpost_parameters.csv` in your output directory:

```
Parameter,Selection
dir_input,/path/to/scprep_output
dir_output,/path/to/scpost_output
input_type,eset
output_type,FALSE
batch_correction_method,harmony
batch_var,Batch
pc_max,30
res_ops,"0.1, 0.3, 0.5, 0.8"
tsne,TRUE
umap,TRUE
iterations,3
```

## Run Template

```{r template}
# Run complete workflow
dataset <- scpost::template_scpost(dir_output = "/path/to/output")

# Results are automatically stored in the object and saved as separate files
```

## Template Outputs

After running, you'll find:

```
output_directory/
├── ExpressionSet.rds (or seurat.rds or sce.rds)
└── scpost_analysis/
    ├── PCA.rds
    ├── PCA_Harmony.rds
    ├── MetaData_Seurat_Clusters.rds
    ├── UMAP/
    │   ├── UMAP_Iteration_1.rds
    │   ├── UMAP_Iteration_2.rds
    │   └── UMAP_Iteration_3.rds
    └── tSNE/
        ├── tSNE_Iteration_1.rds
        ├── tSNE_Iteration_2.rds
        └── tSNE_Iteration_3.rds
```


***

# Summary

***


## Summary: Result Storage by Object Type {-}

| Data Type                | ExpressionSet                | Seurat                             | SingleCellExperiment        |
|:-------------------------|:-----------------------------|:-----------------------------------|:----------------------------|
| **Cluster Assignments**  | `pData(obj)$Seurat_Clusters_Res_X` | `obj@meta.data$Seurat_Clusters_Res_X` | `colData(obj)$Seurat_Clusters_Res_X` |
| **PCA Embeddings**       | `assayData(obj)$Seurat$PCA`  | `obj@reductions$pca`               | `reducedDim(obj, "PCA")`    |
| **UMAP Embeddings**      | `assayData(obj)$Seurat$UMAP$Iteration_X` | `obj@reductions$umap` | `reducedDim(obj, "UMAP_Iteration_X")` |
| **tSNE Embeddings**      | `assayData(obj)$Seurat$tSNE$Iteration_X` | `obj@reductions$tsne` | `reducedDim(obj, "tSNE_Iteration_X")` |
| **Harmony Correction**   | `assayData(obj)$Seurat$PCA_Harmony` | `obj@reductions$harmony`    | `reducedDim(obj, "PCA_Harmony")` |
| **Parameters**           | `assayData(obj)$Params$scpost_Parameters` | `obj@misc$scpost_Parameters` | `metadata(obj)$scpost_Parameters` |


# Conclusion {-}

The `scpost` package provides flexible post-processing workflows for single-cell RNA-seq data:

- **Core functions** for step-by-step control
- **Template workflow** for automated analysis
- **Multiple object types** (ExpressionSet, Seurat, SingleCellExperiment)
- **Batch correction** with Harmony or CCA
- **Flexible input/output** with object type conversion

Choose the workflow that best fits your analysis needs. For more information, see:

- **scprep**: https://github.com/g-duclos/scprep
- **Seurat**: https://satijalab.org/seurat/
- **Harmony**: https://github.com/immunogenomics/harmony
